import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { activateLicense, activateLicenseWithEula } from './licensing.js';

// Sample responses based on actual F5 license server responses
const EULA_RESPONSE = `<?xml version="1.0" encoding="utf-8"?>
<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <soapenv:Body>
    <ns1:getLicenseResponse soapenv:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/" xmlns:ns1="https://activate.f5.com/license/services/urn:com.f5.license.v5b.ActivationService">
      <getLicenseReturn href="#id0"/>
    </ns1:getLicenseResponse>
    <multiRef id="id0" soapenc:root="0" soapenv:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/" xsi:type="ns2:LicenseTransaction" xmlns:soapenc="http://schemas.xmlsoap.org/soap/encoding/" xmlns:ns2="urn:com.f5.license.v5b">
      <eula xsi:type="soapenc:string">END USER LICENSE AGREEMENT

DOC-0355-19

IMPORTANT - READ BEFORE INSTALLING OR USING THIS PRODUCT

YOU AGREE TO BE BOUND BY THE TERMS OF THIS LICENSE BY INSTALLING,
HAVING INSTALLED, COPYING, OR OTHERWISE USING THE SOFTWARE.</eula>
      <state xsi:type="soapenc:string">EULA_REQUIRED</state>
    </multiRef>
  </soapenv:Body>
</soapenv:Envelope>`;

const LICENSE_RESPONSE = `<?xml version="1.0" encoding="utf-8"?>
<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <soapenv:Body>
    <ns1:getLicenseResponse soapenv:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/" xmlns:ns1="https://activate.f5.com/license/services/urn:com.f5.license.v5b.ActivationService">
      <getLicenseReturn href="#id0"/>
    </ns1:getLicenseResponse>
    <multiRef id="id0" soapenc:root="0" soapenv:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/" xsi:type="ns2:LicenseTransaction" xmlns:soapenc="http://schemas.xmlsoap.org/soap/encoding/" xmlns:ns2="urn:com.f5.license.v5b">
      <license xsi:type="soapenc:string">#
Auth vers :                        5b
#
#       BIG-IP System License Key File
#       DO NOT EDIT THIS FILE!!
#
#       Install this file as &quot;/config/bigip.license&quot;.
#
Usage :                            F5 Internal Product Development
#
Registration Key :                 FKSRB-VZNQL-JUXKS-YBQDE-ZMGGQHH
Licensed date :                    20251229
License start :                    20251228
License end :                      20260213
Service check date :               20251229
#
Platform ID :                      Z100
#</license>
      <state xsi:type="soapenc:string">LICENSE_RETURNED</state>
    </multiRef>
  </soapenv:Body>
</soapenv:Envelope>`;

// Response without explicit state (relies on content detection)
const LICENSE_RESPONSE_NO_STATE = `<?xml version="1.0" encoding="utf-8"?>
<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <soapenv:Body>
    <ns1:getLicenseResponse soapenv:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/" xmlns:ns1="https://activate.f5.com/license/services/urn:com.f5.license.v5b.ActivationService">
      <getLicenseReturn href="#id0"/>
    </ns1:getLicenseResponse>
    <multiRef id="id0" soapenc:root="0" soapenv:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/" xsi:type="ns2:LicenseTransaction" xmlns:soapenc="http://schemas.xmlsoap.org/soap/encoding/" xmlns:ns2="urn:com.f5.license.v5b">
      <eula xsi:type="soapenc:string">END USER LICENSE AGREEMENT</eula>
      <license xsi:type="soapenc:string">#
Auth vers :                        5b
#
#       BIG-IP System License Key File
Registration Key :                 TEST-KEY-12345</license>
    </multiRef>
  </soapenv:Body>
</soapenv:Envelope>`;

const FAULT_RESPONSE = `<?xml version="1.0" encoding="utf-8"?>
<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/">
  <soapenv:Body>
    <soapenv:Fault>
      <faultcode>soapenv:Server</faultcode>
      <faultstring>Invalid registration key</faultstring>
    </soapenv:Fault>
  </soapenv:Body>
</soapenv:Envelope>`;

const SAMPLE_DOSSIER = '634fad43f08ea540993795a12cb05d38dbb18d1854db70715e8dd35a354a166d31d0a58eca80f1bdf876871ae1a56bb9b73286c734dffc8b1b49a5ac1e3c395a';

describe('licensing', () => {
  let fetchMock: ReturnType<typeof vi.fn>;

  beforeEach(() => {
    fetchMock = vi.fn();
    vi.stubGlobal('fetch', fetchMock);
  });

  afterEach(() => {
    vi.unstubAllGlobals();
  });

  describe('activateLicense', () => {
    it('should return EULA_REQUIRED when server requires EULA', async () => {
      fetchMock.mockResolvedValueOnce({
        ok: true,
        text: () => Promise.resolve(EULA_RESPONSE),
      });

      const result = await activateLicense({ dossier: SAMPLE_DOSSIER });

      expect(result.success).toBe(false);
      expect(result.eulaRequired).toBe(true);
      expect(result.eula).toContain('END USER LICENSE AGREEMENT');
      expect(result.state).toBe('EULA_REQUIRED');
    });

    it('should return license when server returns LICENSE_RETURNED', async () => {
      fetchMock.mockResolvedValueOnce({
        ok: true,
        text: () => Promise.resolve(LICENSE_RESPONSE),
      });

      const result = await activateLicense({
        dossier: SAMPLE_DOSSIER,
        eula: 'accepted eula text',
      });

      expect(result.success).toBe(true);
      expect(result.license).toContain('Auth vers');
      expect(result.license).toContain('BIG-IP System License Key File');
      expect(result.state).toBe('LICENSE_RETURNED');
    });

    it('should detect license from content when state tag is missing', async () => {
      fetchMock.mockResolvedValueOnce({
        ok: true,
        text: () => Promise.resolve(LICENSE_RESPONSE_NO_STATE),
      });

      const result = await activateLicense({
        dossier: SAMPLE_DOSSIER,
        eula: 'accepted',
      });

      expect(result.success).toBe(true);
      expect(result.license).toContain('Auth vers');
      expect(result.state).toBe('LICENSE_RETURNED');
    });

    it('should return error on SOAP fault', async () => {
      fetchMock.mockResolvedValueOnce({
        ok: true,
        text: () => Promise.resolve(FAULT_RESPONSE),
      });

      const result = await activateLicense({ dossier: SAMPLE_DOSSIER });

      expect(result.success).toBe(false);
      expect(result.error).toBe('Invalid registration key');
    });

    it('should return error on HTTP error', async () => {
      fetchMock.mockResolvedValueOnce({
        ok: false,
        status: 500,
        statusText: 'Internal Server Error',
        text: () => Promise.resolve('Server error'),
      });

      const result = await activateLicense({ dossier: SAMPLE_DOSSIER });

      expect(result.success).toBe(false);
      expect(result.error).toContain('500');
    });

    it('should return error on network failure', async () => {
      fetchMock.mockRejectedValueOnce(new Error('Network error'));

      const result = await activateLicense({ dossier: SAMPLE_DOSSIER });

      expect(result.success).toBe(false);
      expect(result.error).toContain('Network error');
    });

    it('should send correct SOAP envelope structure', async () => {
      fetchMock.mockResolvedValueOnce({
        ok: true,
        text: () => Promise.resolve(LICENSE_RESPONSE),
      });

      await activateLicense({
        dossier: SAMPLE_DOSSIER,
        eula: 'test eula',
        email: 'test@example.com',
      });

      expect(fetchMock).toHaveBeenCalledTimes(1);
      const [url, options] = fetchMock.mock.calls[0];

      expect(url).toBe('https://activate.f5.com/license/services/urn:com.f5.license.v5b.ActivationService');
      expect(options.method).toBe('POST');
      expect(options.headers['SOAPAction']).toBe('""');
      expect(options.headers['Content-Type']).toBe('text/xml; charset=utf-8');
      expect(options.body).toContain('<?xml version="1.0" encoding="UTF-8"?>');
      expect(options.body).toContain('<ns1:getLicense>');
      expect(options.body).toContain(`<dossier xsi:type="ns3:string">${SAMPLE_DOSSIER}</dossier>`);
      expect(options.body).toContain('<eula xsi:type="ns3:string">test eula</eula>');
      expect(options.body).toContain('<email xsi:type="ns3:string">test@example.com</email>');
    });
  });

  describe('activateLicenseWithEula', () => {
    it('should handle full EULA flow automatically', async () => {
      // First call returns EULA_REQUIRED
      fetchMock.mockResolvedValueOnce({
        ok: true,
        text: () => Promise.resolve(EULA_RESPONSE),
      });
      // Second call returns license
      fetchMock.mockResolvedValueOnce({
        ok: true,
        text: () => Promise.resolve(LICENSE_RESPONSE),
      });

      const result = await activateLicenseWithEula({ dossier: SAMPLE_DOSSIER });

      expect(fetchMock).toHaveBeenCalledTimes(2);
      expect(result.success).toBe(true);
      expect(result.license).toContain('Auth vers');
    });

    it('should return license directly if no EULA required', async () => {
      // Server returns license on first call
      fetchMock.mockResolvedValueOnce({
        ok: true,
        text: () => Promise.resolve(LICENSE_RESPONSE),
      });

      const result = await activateLicenseWithEula({ dossier: SAMPLE_DOSSIER });

      expect(fetchMock).toHaveBeenCalledTimes(1);
      expect(result.success).toBe(true);
      expect(result.license).toContain('Auth vers');
    });

    it('should pass EULA from first call to second call', async () => {
      fetchMock.mockResolvedValueOnce({
        ok: true,
        text: () => Promise.resolve(EULA_RESPONSE),
      });
      fetchMock.mockResolvedValueOnce({
        ok: true,
        text: () => Promise.resolve(LICENSE_RESPONSE),
      });

      await activateLicenseWithEula({ dossier: SAMPLE_DOSSIER });

      // Check second call includes EULA
      const secondCallBody = fetchMock.mock.calls[1][1].body;
      expect(secondCallBody).toContain('END USER LICENSE AGREEMENT');
    });
  });

  describe('XML entity decoding', () => {
    it('should decode XML entities in license text', async () => {
      const responseWithEntities = LICENSE_RESPONSE.replace(
        '/config/bigip.license',
        '/config/bigip.license&amp;test&lt;value&gt;'
      );

      fetchMock.mockResolvedValueOnce({
        ok: true,
        text: () => Promise.resolve(responseWithEntities),
      });

      const result = await activateLicense({
        dossier: SAMPLE_DOSSIER,
        eula: 'accepted',
      });

      expect(result.success).toBe(true);
      expect(result.license).toContain('&test<value>');
      expect(result.license).not.toContain('&amp;');
      expect(result.license).not.toContain('&lt;');
      expect(result.license).not.toContain('&gt;');
    });
  });
});
